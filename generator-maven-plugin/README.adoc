JUDO Tatami JSL Archetype maven plugin
======================================

This plugin manages and executes generators for JUDO JSL models.

It generates text based codes / reports from JSL model with the given templates.

== Requirements

- Maven 3.8.3 and Java 11

== Installation

Include the plugin as a dependency in your Maven project. Change `LATEST_VERSION` to the latest tagged version.

```
<plugin>
    <groupId>hu.blackbelt.judo.meta</groupId>
	<artifactId>judo-jsl-generator-maven-plugin</artifactId>
    <version>LATEST_VERSION</version>
    ...
</plugin>
...

```

== Usage

Executing a template for an JSL model

```
<plugin>
   <groupId>hu.blackbelt.judo.meta</groupId>
   <artifactId>judo-jsl-generator-maven-plugin</artifactId>
   <version>${judo-meta-jsl-version}</version>
   <executions>
      <execution>
            <id>execute-jsl-test-model-from-artifact</id>
            <phase>test</phase>
            <goals>
               <goal>generate</goal>
            </goals>
            <configuration>
               <jslModel> <!--1-->
                  mvn:hu.blackbelt.judo.tatami:judo-tatami-test-jsl:${judo-tatami-version}!model/test-jsldsl.model
               </jslModel>
               <sources> <!--2-->
                  mvn:hu.blackbelt.judo.tatami:judo-tatami-test-jsl:${judo-tatami-version}!model
               </surces>
               <scanSources>false</scanSources> <!--3-->
               <modelNames> <!--4-->
                  ModelName,ModelName2
               </modelNames>
               <srcModelTarget> <!--5-->
                     ${project.basedir}/target/classes/model
               </srcModelTarget>
               <uris> <!--6-->
                  <uri>mvn:hu.blackbelt.judo.meta:judo-hsk-fullstack-karaf-project-archetype:${judo-jsl-fullstack-karaf-project-template-version}</uri>
                  <uri>${basedir}/src/main/resources</uri>
               </uris>
               <helpers> <!--7-->
                  <helper>hu.blackbelt.judo.jsl.fullstack.project.archetype.PsmProjectHelper</helper>
               </helpers>
               <type>fullstack-project</type> <!--8-->
               <destination>${basedir}/target/test-classes/js/artifact</destination> <!--9-->
               <templateParameters> <!--10-->
                  <judoPlatformVersion>${judo-platform-version}</judoPlatformVersion>
               </templateParameters>
               <contextAccessor>hu.blackbelt.judo.jsl.fullstack.project.archetype.ActorTypeValueResolver</contextAccessor> <!--11-->
               <scanDependencies>true</scanDependencies> <!--12-->
               <actors></actors> <!--12-->
            </configuration>
      </execution>
   </executions>

    <!--  these dependencies are just example models for testing. -->
    <dependencies>
        <dependency>
            <groupId>hu.blackbelt.judo.meta</groupId>
            <artifactId>hu.blackbelt.judo.meta.jsl.model.northwind</artifactId>
            <version>${judo-meta-jsl-version}</version>
        </dependency>

        <dependency>
            <groupId>hu.blackbelt.judo.meta</groupId>
            <artifactId>judo-jsl-fullstack-karaf-project-archetype</artifactId>
            <version>${judo-jsl-fullstack-karaf-project-template-version}</version>
        </dependency>

    </dependencies>
</plugin>

```

In the parameter URI type parameters can be file or mvn with the following coordinate:
`mvn:<groupId>:<artifactId>[:<extension>[:<classifier>]]:<version>[!path/in/archive]`

<1> (Optional) JSL standalone model `model` file URI. When it is defined, `sources` is ignored

<2> (Optional) JSL model source URI's to search for `jsl` files.

<3> (Optional) Scan sources from dependencies. It is used when `sources` is used.
+
(Default: `false`)

<4> (Optional) Logical model names. When multiple `jsl` files are defined, by default all of them are compiled. Most of the time only one or more dedicated model can be compiled with the list of the names. (the name which is dfined as `model` in the first line of `.jsl`)
+
(Default: <none>)

<5> Template URIs. The templates loaded from URI's. The order is reverse, first try to load from last URI, when the resource
not found there step back to previous defined URI. So it's a layered loader, where the templates can be extended and
overrided with other template packages.

<6> Model target which is used by resource plugin to copy model. From this directory every `jsl` files
are deleted to support maven command without clean and avoid duplicate model validation error.
+
(Default: `${project.basedir}/target/classes/model`)

<7> (Optional) Helper classes. It contains methods which can be used in SpringEL (project yaml definition expressions) and in the
handlebars templates. The helper classes can be loaded from plugin's classloaders, so the helper's class can
be presented in plugin's or the project's dependencies. When a helper implements the `com.github.jknack.handlebars.ValueResolver`
interface automatically registered as a handlebar value resolver. When `scanDependencies` parameter is `true`, the scanned
helpers and the given ones are merged.

<8> Project type. It is used to resolve the project descriptor yaml files. The yaml file name is `<project type>.yaml`.
One template can countains several project type description, so same templates can be used for multiple project skeleton types.

<9> Destination path where the transformation output is generated. When no actor or more than one actor is defined, for all actors
different folder generated by name.
+
(Default: ${project.basedir}/target/classes/model.)

<10> Template parameters. The defined parameters here can be accessed in SpringEL and handlebars
templates with the same name.

<11> ContextAccessor. It can be used to store Handlebars / SpringEL / Parameters Context which can be accessed by type resolvers.
When `scanDependencies` value is `true`, the classes annotated with `@hu.blackbelt.judo.generator.commons.annotations.ContextAccessor` are
set as accessor. When multiple instances are presented, error is thrown.
It can implement any of the following methods, depends on which context can be registered:
- `public static void bindContext(com.github.jknack.handlebars.Context)` Register handlebars context. It is called immediately before templating,
   so it is not recommended to use to calculate factory or path values with it.
- `public static void bindContext(org.springframework.expression.spel.support.StandardEvaluationContext context)` It registers
   Spring Expression Language context. It is called before any templating, it can be used in yaml and template context too.
- `public static void bindContext(java.util.Map<String, Object> parameters`)
   It is registers the given external parameters. It is called before any templating, it can be used in yaml and template context too.

<12> Scan dependencies. It scans classpath for classes annotated with `@hu.blackbelt.judo.generator.commons.annotations.TemplateHelper` and
`@hu.blackbelt.judo.generator.commons.annotations.ContextAccessor` annotated classes.

<13> Actors used for generation. When it is not set all actors are generated. To define use coma separated fully qualified name of actor class.

Our recommendation is to store the context in ThreadLocal, because
templating is running in multiple threads.


== Generation

For code generation handlebars template is used. The `<project type>.yaml` file
describes what template is used for that and control which parameters
are passed and JSL model can control HOW the templates can be used.

== Override templates in generation

The template overrides can contain a `<project type>.yaml` which can be empty, on that case the
existing templates can be overrided only. The contents of project files can be used to override existing
template definition or can be added new templates. The overrided preferences are processed in a reverse order, so the last defined override is the strongest.
All of the templates can be decorated, when the original file name is suffixed with `override.hbs`. When it is
defined the original one can be included with the standard fragment syntax of handlebars.
Another way of override is to redefine the template for the given template name.

== <project type>.yaml file

This file is used to control generation process. This file is using the JSL model and the given helpers.

For expression processing, the SpringEL expression language is used. The helpers are binded as
handlebars helper and SpringEL helper too.

```
- name: file_for_actor (1)
  factoryExpression: "{#actorTypes}" (2)
  actorTypeBased: false (3)
  exclude: false (4)
  pathExpression: >
    'lib/' +
    #path(#actorType.name) + '/' +
    'file_for_actor.test' (5)
  templateName: lib/file_for_actor.test.hbs (6)
  templateContext: (7)
    - name: actorTypeAsVariable
      expression: "#self"
  copy: false (8)
```

<1> The name of the template. It can be used to redefine template in a later override.

<2> Factory expression is used to create files. It returns a list of
objects which are used as root context for the given handlebar template. (`templateName`)

<3> When actorTypeBased template used, the template called for all actor types and
the `actorType` variable is defined.

<4> This parameter can be used in an override to exclude the given template from a generation.
With this parameter only the `name` is effective

<5> Path expression returns with a path where the generated file is placed.

<6> Template is used for generation.

<7> Template context is used to put expression result to template
variable.

<8> It can be used to copy a binary file. In this case the template file used as binary, no
templating is performed. In this case `factoryExpression`, `pathExpression` are used.


== Ignore files on generation

Sometimes a developer needs to replace generated file with custom developed file. On that case
the generator has to ignore the given file to keep the edited version. To achieve this
`.generator-ignore` file can be used.  It uses glob format, so the usage is same as '.gitignore'.



=== Example

There are two templates. First one is the 'base`, second one is the `override`.
The effective output will be calculated that way that the `override` is rolled to `base`.
Means if the `override` template entry with the same `name` has an entry, all
off the original definitions are replaced with the `override` version. When a
`override` template does not contain the original name, nothing will happend, except
the `base` entry's `templateName` file is placed as override template.
There is one special field, called `exclude` which is excluding the `base` template.

==== `base`

```
templates:
  - name: testOverride
    pathExpression: "#actorType.name + '/actorToOverride'"
    templateName: test1/actorToOverride.hbs
    actorTypeBased: true

  - name: testReplace
    pathExpression: "#actorType.name + '/actorToReplace'"
    templateName: test1/actorToReplace.hbs
    actorTypeBased: true

  - name: testDelete
    pathExpression: "#actorType.name + '/actorToDelete'"
    templateName: test1/actorToDelete.hbs
    actorTypeBased: true
```

With templates:

- `test1/actorToDelete.hbs`
- `test1/actorToOverride.hbs`
- `test1/actorToReplace.hbs`

Effective output is:

- `/actorName/actorToOverrride`
- `/actorName/actorToReplace`
- `/actorName/actorToDelete`


==== `override`


```
templates:
  - name: testReplace
    pathExpression: "#actorType.name + '/actorReplaced'"
    templateName: test1/actorReplaced.hbs
    actorTypeBased: true

  - name: testDelete
    exclude: true
```


With templates:

- `test1/actorReplaced.hbs`
- `test1/actorToOverride.override.hbs`


In this case the effective output is:

- `/actorName/actorToOverrride`  (with the content of `actorToOverride.override.hbs`)
- `/actorName/actorReplaced`
