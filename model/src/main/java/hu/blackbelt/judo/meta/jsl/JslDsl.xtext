grammar hu.blackbelt.judo.meta.jsl.JslDsl hidden(WS, NL, SL_COMMENT, ML_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate jsldsl "http://www.blackbelt.hu/judo/meta/jsl/JslDsl"

 
ModelDeclaration returns ModelDeclaration hidden(WS, SL_COMMENT, ML_COMMENT)
    : {ModelDeclaration} 'model' name = ModelName
      imports += ModelImport*
	  (declarations += Declaration)*
	  NL*
    ;

JSLID : ID | 'boolean' | 'binary' | 'string' | 'numeric' | 'date' | 'time' | 'timestamp'
	       | 'regex' | 'precision' | 'scale'
	       | 'DESC' | 'ASC'
	;


ModelImport
    : NL+ 'import' modelName = ModelImportDeclaration
	;

ModelImportDeclaration
    : importName = ModelName ('as' alias = JSLID)?
	;

Declaration
	: NL+ (TypeDeclaration
	| ErrorDeclaration
	| QueryDeclaration )
	;


TypeDeclaration
	: PrimitiveDeclaration
	| ClassDeclaration
	;

PrimitiveDeclaration
	: EnumDeclaration
	| DataTypeDeclaration
    ;

ClassDeclaration
	: EntityDeclaration
	;

/****************************
 *	Entity
 ****************************/
fragment Named
	: name = JSLID;

fragment Cardinality
    : isMany ?= '[]'
    ;

EntityDeclaration
	: {EntityDeclaration}
	  'entity' isAbstract ?= 'abstract'? Named
	  ('extends' extends += [EntityDeclaration | LocalName] (',' extends += [EntityDeclaration | LocalName])*)?
	  BLOCK_START (members += EntityMemberDeclaration)* BLOCK_END
	;


QueryDeclaration
	: 'query' (referenceType = [SingleType | LocalName] Cardinality?) Named
	  ('(' parameters += QueryDeclarationParameter (',' parameters += QueryDeclarationParameter)* ')')
	  "=>" expression = Expression
	;

EntityMemberDeclaration
	: NL+ (EntityFieldDeclaration
	| EntityIdentifierDeclaration
	| EntityRelationDeclaration
	| EntityDerivedDeclaration
	| EntityQueryDeclaration
	| ConstraintDeclaration)
	;

ConstraintDeclaration
	: 'constraint' Named expression = Expression ('onerror' error = CreateError)?
	;

EntityFieldDeclaration
	: 'field' (isRequired ?= 'required'? referenceType = [SingleType | LocalName] Cardinality?) Named
	  (defaultExpression = DefaultExpressionType)?
	;


DefaultExpressionType
	: {DefaultExpressionType} '=' expression = 
		( Expression )
	;

SingleType 
	: PrimitiveDeclaration
	| EntityDeclaration
	;

EntityIdentifierDeclaration
	: 'identifier' isRequired ?= 'required'? referenceType = [PrimitiveDeclaration | LocalName] Named
	  (defaultExpression = DefaultExpressionType)?
	;

EntityDerivedDeclaration
	: 'derived' (referenceType = [SingleType | LocalName] Cardinality?) Named
	  "=>" expression = Expression
	;

EntityQueryDeclaration
	: 'query' (referenceType = [EntityQueryTargetType | LocalName] Cardinality?) Named
	  ('(' parameters += QueryDeclarationParameter (',' parameters += QueryDeclarationParameter)* ')')
	  "=>" expression = Expression
	;

EntityQueryTargetType
	: PrimitiveDeclaration
	| EntityDeclaration
	;

QueryDeclarationParameter
	: referenceType = [PrimitiveDeclaration | LocalName] Named "=" default = Literal
	;

EntityRelationDeclaration
	: 'relation' (isRequired ?= 'required'? referenceType = [EntityDeclaration | LocalName] Cardinality?) Named
	  opposite = EntityRelationOpposite?
	;

EntityRelationOpposite
	: EntityRelationOppositeInjected
	| EntityRelationOppositeReferenced
	;

EntityRelationOppositeInjected
	: 'opposite-add' Named Cardinality?
	;

EntityRelationOppositeReferenced
	: 'opposite' oppositeType = [EntityRelationDeclaration | LocalName]
	;


/****************************
 *	Error
 ****************************/

ErrorDeclaration
	: 'error' Named ('extends' extends = [ErrorDeclaration | LocalName])?
	  BLOCK_START (fields += ErrorField)* BLOCK_END
	;

ErrorField
	: NL+ 'field' referenceType = [PrimitiveDeclaration | LocalName] Named
	  (defaultExpression = DefaultExpressionType)?
	;

CreateError
	: errorDeclarationType=[ErrorDeclaration | LocalName] ('(' (parameters+=ThrowParameter (',' parameters+=ThrowParameter)*)? ')')?
	;

ThrowParameter
	: errorFieldType=[ErrorField | LocalName] '=' expession=Literal;



/****************************
 *	Datatype
 ****************************/

    
DataTypeDeclaration hidden(WS, CONT_NL, SL_COMMENT, ML_COMMENT)
    : 'type'
      (
		  BooleanPrimitive
		| BinaryPrimitive '(' mimeTypes = ModifierMimeTypes ',' maxFileSize = ModifierMaxFileSize ')'
		| StringPrimitive '(' maxLength = ModifierMaxLength (',' regex = ModifierRegex)? ')'
		| NumericPrimitive '(' precision = ModifierPrecision ',' scale = ModifierScale ')'
		| DatePrimitive
		| TimePrimitive
		| TimestampPrimitive
      )
    ;

BooleanPrimitive returns DataTypeDeclaration: primitive = 'boolean' Named;
BinaryPrimitive returns DataTypeDeclaration : primitive = 'binary' Named;
StringPrimitive returns DataTypeDeclaration : primitive = 'string' Named;
NumericPrimitive returns DataTypeDeclaration : primitive = 'numeric' Named;
DatePrimitive returns DataTypeDeclaration : primitive = 'date' Named;
TimePrimitive returns DataTypeDeclaration : primitive = 'time' Named;
TimestampPrimitive returns DataTypeDeclaration : primitive = 'timestamp' Named;



/****************************
 *	Enum
 ****************************/

EnumDeclaration
    : 'enum' Named
      BLOCK_START (literals += EnumLiteral)+ BLOCK_END
    ;

EnumLiteral
    : NL+ Named '=' value = INTEGER
    ;


ModifierMaxLength
	: 'max-length' '=' value = INTEGER
	;

ModifierRegex
	: 'regex' '=' regex = StringLiteral
	;

ModifierPrecision
	: 'precision' '=' value = INTEGER
	;

ModifierScale
	: 'scale' '=' value = INTEGER
	;

ModifierMimeTypes
	: 'mime-types' '=' '[' values += MimeType (',' values += MimeType)* ']'
	;

MimeType
	: value = StringLiteral
	;

ModifierMaxFileSize
	: 'max-file-size' '=' numeric = INTEGER (unit = DataUnit)?
	;
	
enum DataUnit
	: KB = 'kB'
	| MB = 'MB'
	| GB = 'GB'
	| KiB = 'KiB'
	| MiB = 'MiB'
	| GiB = 'GiB'
	;

/****************************
 *	Expression
 ***************************/

Expression returns Expression hidden(WS, CONT_NL, SL_COMMENT, ML_COMMENT)
	: SwitchExpression (=> ({Expression.switchExpression=current}) parenthesizedExpression=ParenthesizedExpression)*
	;

ParenthesizedExpression returns Expression
	: {ParenthesizedExpression} '(' => expression = MultilineExpression ')'
	;

MultilineExpression returns Expression hidden(WS, NL, CONT_NL, SL_COMMENT, ML_COMMENT)
	: SwitchExpression
	;

// right associative rule
SwitchExpression returns Expression
	: ImpliesExpression (=> ({TernaryOperation.condition=current} '?')
	  thenExpression=SwitchExpression ':'
      elseExpression=SwitchExpression)?
    ;

ImpliesExpression returns Expression
	: OrExpression (=> ({BinaryOperation.leftOperand=current} operator='implies') rightOperand=OrExpression)*
	;

OrExpression returns Expression
	: XorExpression (=> ({BinaryOperation.leftOperand=current} operator='or') rightOperand=XorExpression)*
	;

XorExpression returns Expression
	: AndExpression (=> ({BinaryOperation.leftOperand=current} operator='xor') rightOperand=AndExpression)*
	;

AndExpression returns Expression
	: EqualityExpression (=> ({BinaryOperation.leftOperand=current} operator='and') rightOperand=EqualityExpression)*
	;

EqualityExpression returns Expression
	: RelationalExpression (=> ({BinaryOperation.leftOperand=current} operator=('!='|'==')) rightOperand=RelationalExpression)*
	;

RelationalExpression returns Expression
	: AdditiveExpression (=> ({BinaryOperation.leftOperand=current} operator=('>=' | '<=' | '>' | '<')) rightOperand=AdditiveExpression)*
	;

AdditiveExpression returns Expression
	: MultiplicativeExpression (=> ({BinaryOperation.leftOperand=current} operator=('+'|'-')) rightOperand=MultiplicativeExpression)*
	;

MultiplicativeExpression returns Expression
	: ExponentExpression (=> ({BinaryOperation.leftOperand=current} operator=('*' | '/' | 'div' | 'mod')) rightOperand=ExponentExpression)*
	;

ExponentExpression returns Expression
	: SpawnOperation (=> ({BinaryOperation.leftOperand=current} operator='^') rightOperand=SpawnOperation)*
	;

SpawnOperation returns Expression
	: UnaryOperation (=> ({SpawnOperation.operand=current} 'as' spawnTargetType=LocalName))?
	;

UnaryOperation returns Expression
	: {UnaryOperation} operator=('not' | '-') operand=FunctionedExpression
    | FunctionedExpression
    ;

FunctionedExpression returns Expression
	: FunctionableExpression ({FunctionedExpression.operand=current} functionCall=FunctionCall)?
	| ParenthesizedExpression
	| EnumLiteralReference
    ;

Literal returns Expression
	: BooleanLiteral
	| NumberLiteral
	| StringLiteral
	| TemporalLiteral
	;

BooleanLiteral returns Expression
	: {BooleanLiteral} ('false' | isTrue?='true')
	;

NumberLiteral returns Expression
	: {IntegerLiteral} value=INTEGER
	| {DecimalLiteral} value=DECIMAL
	;

StringLiteral returns Expression
	: {EscapedStringLiteral} value=STRING
	| {RawStringLiteral} value=RAW_STRING
	;

TemporalLiteral returns Expression
	: {DateLiteral} value=DATE
	| {TimeStampLiteral} value=TIMESTAMP
	| {TimeLiteral} value=TIME
	;


FunctionableExpression returns Expression
	: NavigationExpression
	| Literal
	;

NavigationExpression returns Expression
	: SelfExpression
	| NavigationBaseExpression
	| QueryCallExpression
	;

NavigationBaseExpression returns NavigationExpression
	: {NavigationBaseExpression} navigationBaseType = [NavigationBaseReference | LocalName]  (features+=Feature*)
	;
	
NavigationBaseReference
	: EntityDeclaration
	| QueryDeclaration
	| LambdaVariable
	| QueryDeclarationParameter
	| PrimitiveDeclaration
	;
	
SelfExpression returns NavigationExpression
	: {SelfExpression} isSelf ?= 'self' (features+=Feature*)		
	;

QueryCallExpression returns NavigationExpression
	: {QueryCallExpression} queryDeclarationType = [ QueryDeclaration | LocalName ] '(' (parameters+=QueryParameter (',' parameters+=QueryParameter)*)? ')' (features+=Feature*)
	;

EnumLiteralReference returns NavigationExpression
    : {EnumLiteralReference} enumDeclaration = [EnumDeclaration | LocalName] '#' enumLiteral = [EnumLiteral | EnumLiteralName ]    	
    ;

FunctionCall
	: {FunctionCall} '!' function=Function features+=Feature* call=FunctionCall?
	;

Feature
    : {Feature} {Feature.base = current} '.' navigationTargetType = [NavigationTarget | LocalName]('(' (parameters+=QueryParameter (',' parameters+=QueryParameter)*)? ')')?
    ;

NavigationTarget
    : EntityMemberDeclaration
    | EntityDeclaration
    | EntityRelationOppositeInjected
    ;


QueryParameter
	:  queryParameterType=[QueryDeclarationParameter | QueryParameterName] '=' (literal = Literal | parameter = [QueryDeclarationParameter | QueryParameterName])     // expression=MultilineExpression
	;


CreateExpression returns Expression
	: {CreateExpression} 'new' createType=[ClassDeclaration | LocalName]
	  (   '(' (assignments+=CreateParameter (',' assignments+=CreateParameter)*)? ')'
	  	| '[' (creates += MultilineExpression (',' creates += MultilineExpression)*)? ']'
	  )
	;

CreateParameter: name=JSLID '=' right=MultilineExpression;

/**
 * Function
 */

Function
	: LiteralFunction
	| LambdaFunction
//	| SelectorFunction
	;


FunctionParameter
	: LiteralFunctionParameters
	| LambdaFunctionParameters
	| SelectorFunctionParameters
	;

LiteralFunction returns Function: {LiteralFunction} functionDeclarationReference = [LiteralFunctionDeclaration | LocalName ] '(' (parameters += LiteralFunctionParameter (',' parameters += LiteralFunctionParameter)*)? ')' ;
LambdaFunction returns Function : {LambdaFunction} functionDeclarationReference = [LambdaFunctionDeclaration | LocalName ] '(' lambdaArgument=LambdaVariable '|' expression = Expression ')';
//SelectorFunction returns Function : {SelectorFunction} => functionDeclarationReference = [SelectorFunctionDeclaration | LocalName ] '('  selectorArgument = SelectorVariable '|' selectors += SelectorDeclaration (',' selectors += SelectorDeclaration)* ')';

LiteralFunctionParameters
    : {LiteralFunctionParameters} parameters += LiteralFunctionParameter (',' parameters += LiteralFunctionParameter)*
	;

LiteralFunctionParameter 
	: declaration = [FunctionParameterDeclaration | LocalName] '=' expression=Expression 
	;

LambdaFunctionParameters
    : lambdaArgument=LambdaVariable '|' expression = Expression
	;
    
LambdaVariable
    : {LambdaVariable} Named    	
    ;

SelectorFunctionParameters
    : {SelectorFunctionParameters} selectorArgument=SelectorVariable '|' selectors += SelectorDeclaration (',' selectors += SelectorDeclaration)*
	;

SelectorDeclaration
    : {SelectorDeclaration} selector = [SelectorVariable | LocalName] '.' member = [EntityMemberDeclaration | LocalName] ('DESC' | isTrue?='ASC')?
    ;

SelectorVariable
    : {SelectorVariable} Named
    ;

/**
 *  Function declaration
 */
enum FunctionReturnType
	: RT_ENTITY_INSTANCE
	| RT_ENTITY_COLLECTION
	| RT_BASE_TYPE_INSTANCE
	| RT_BASE_TYPE_COLLECTION
	| RT_ENUM_LITERAL
	| RT_BOOLEAN_INSTANCE
	| RT_BINARY_INSTANCE
	| RT_STRING_INSTANCE
	| RT_NUMERIC_INSTANCE
	| RT_DATE_INSTANCE
	| RT_TIME_INSTANCE
	| RT_TIMESTAMP_INSTANCE
	;

enum FunctionBaseType
	: BT_ENTITY_INSTANCE
	| BT_ENTITY_COLLECTION
	| BT_ENUM_LITERAL
	| BT_BOOLEAN_INSTANCE
	| BT_BINARY_INSTANCE
	| BT_STRING_INSTANCE
	| BT_NUMERIC_INSTANCE
	| BT_DATE_INSTANCE
	| BT_TIME_INSTANCE
	| BT_TIMESTAMP_INSTANCE
	| BT_BOOLEAN_TYPE
	| BT_BINARY_TYPE 
	| BT_STRING_TYPE
	| BT_NUMERIC_TYPE
	| BT_DATE_TYPE
	| BT_TIME_TYPE
	| BT_TIMESTAMP_TYPE
	;

enum FunctionParameterType
	: PT_ENTITY_INSTANCE
	| PT_ENTITY_COLLECTION
	| PT_ENTITY_TYPE
	| PT_ENUM_LITERAL
	| PT_BOOLEAN_INSTANCE
	| PT_BINARY_INSTANCE
	| PT_STRING_INSTANCE
	| PT_NUMERIC_INSTANCE
	| PT_DATE_INSTANCE
	| PT_TIME_INSTANCE
	| PT_TIMESTAMP_INSTANCE
	;

FunctionDeclaration 
	: (
	LiteralFunctionDeclaration
	| LambdaFunctionDeclaration
	| SelectorFunctionDeclaration
	) returnTypes+=FunctionReturnType acceptedBaseTypes+=FunctionBaseType parameterDeclarations += FunctionParameterDeclaration
	;

LambdaFunctionDeclaration returns NamedFunctionDeclaration : {LambdaFunctionDeclaration} ;
LiteralFunctionDeclaration returns NamedFunctionDeclaration : {LiteralFunctionDeclaration}  ;
SelectorFunctionDeclaration returns NamedFunctionDeclaration : {SelectorFunctionDeclaration} ;


NamedFunctionDeclaration returns FunctionDeclaration : {NamedFunctionDeclaration} name = JSLID;

FunctionParameterDeclaration
    : {FunctionParameterDeclaration} Named Cardinality isRequired ?= 'true' functionParameterType = FunctionParameterType parameterPresentedForBaseTypes += FunctionBaseType;
    

	

EnumLiteralName
	: JSLID
    ;

QueryParameterName
	: JSLID
    ;

LocalName
	: (JSLID '::')? JSLID
    ;

ModelName
	: JSLID('::' JSLID)*
    ;

/****************************
 *	Terminals
 ****************************/

BLOCK_START
	: NL* '{'
	;

BLOCK_END
	: NL* '}'
	;

terminal fragment DIGIT
	: '0'..'9'
	;

terminal fragment ALPHABET
    : 'a'..'z' | 'A'..'Z'    	
    ;

terminal fragment NEWLINE
    : '\n' | '\r'   	
    ;

terminal TIMESTAMP
	: '`' DIGIT+ '-' DIGIT DIGIT '-' DIGIT DIGIT 'T' DIGIT DIGIT ':' DIGIT DIGIT (':' DIGIT DIGIT ('.' DIGIT+ )? )? ('Z' | ('+' | '-') DIGIT DIGIT ':' DIGIT DIGIT )'`'
	;

terminal TIME
	: '`' DIGIT DIGIT ':' DIGIT DIGIT (':' DIGIT DIGIT ('.' DIGIT+ )? )? '`'
	;

terminal DATE
	: '`' DIGIT+ '-' DIGIT DIGIT '-' DIGIT DIGIT '`'
	;

terminal DECIMAL returns ecore::EBigDecimal
	: '-'? DIGIT+ '.' DIGIT+
	;

terminal INTEGER returns ecore::EBigInteger
	: '-'? DIGIT+
	;

terminal ID
	: ALPHABET (ALPHABET | DIGIT)* | '`' ALPHABET (ALPHABET | DIGIT)* '`'
	;

terminal STRING
	: '"' ('\\' ('t'|'n'|'f'|'r'|'"'|'\\') | !('\\' | '"' | NEWLINE))* '"'
	;

terminal RAW_STRING
	: 'r"' (!('"' | NEWLINE))* '"'
	;

terminal CONT_NL
	: '\\' (' ' | '\t')* '\r'? '\n'
	;
 
terminal ML_COMMENT
	: '/*'->'*/'
	;

terminal SL_COMMENT
	: '//' !(NEWLINE)*
	;

terminal WS
	: (' ' | '\t')+
	;

terminal NL
	: NEWLINE | ';'
	;

	