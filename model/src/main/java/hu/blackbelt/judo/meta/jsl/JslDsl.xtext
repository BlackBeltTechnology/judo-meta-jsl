grammar hu.blackbelt.judo.meta.jsl.JslDsl hidden(WS, NL, SL_COMMENT, ML_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate jsldsl "http://www.blackbelt.hu/judo/meta/jsl/JslDsl"
 
ModelDeclaration returns ModelDeclaration hidden(WS, SL_COMMENT, ML_COMMENT)
    : {ModelDeclaration} 'model' name = ModelName
      imports += ModelImport*
	  (declarations += Declaration)*
	  NL*
    ;

//ModelImport
//    : =>NL+ 'import' importedModel = [ModelDeclaration] ('as' alias = ID)?
//	;

ModelImport
    : NL+ 'import' modelName = ModelImportDeclaration
	;

ModelImportDeclaration
    : importName = ModelName ('as' alias = ID)?
	;

Declaration
	: NL+ (TypeDeclaration
	| ErrorDeclaration)
	;

TypeDeclaration
	: PrimitiveDeclaration
	| ClassDeclaration
	;

PrimitiveDeclaration
	: DataTypeDeclaration
	| EnumDeclaration
    ;

ClassDeclaration
	: EntityDeclaration
	;

/****************************
 *	Entity
 ****************************/

EntityDeclaration returns EntityDeclaration
	: {EntityDeclaration}
	  'entity' isAbstract ?= 'abstract'? name = ID
	  ('extends' extends += [EntityDeclaration | LocalName] (',' extends += [EntityDeclaration | LocalName])*)?
	  BLOCK_START (members += EntityMemberDeclaration)* BLOCK_END
	;

EntityMemberDeclaration
	: NL+ (EntityFieldDeclaration
	| EntityIdentifierDeclaration
	| EntityRelationDeclaration
	| EntityDerivedDeclaration
	| ConstraintDeclaration)
	;

ConstraintDeclaration
	: 'constraint' expression = Expression ('onerror' error = CreateError)?
	;

EntityFieldDeclaration
	: 'field' (isRequired ?= 'required'? singleType = [EntityFieldSingleType | LocalName] | arrayType = [EntityDeclaration | LocalName] '[]') name = ID
	  ("=" default = Expression)?
	;

EntityFieldSingleType
	: PrimitiveDeclaration
	| EntityDeclaration
	;

EntityIdentifierDeclaration
	: 'identifier' isRequired ?= 'required'? type = [PrimitiveDeclaration | LocalName] name = ID
	  ("=" default = Expression)?
	;

EntityDerivedDeclaration
	: 'derived' (singleType = [EntityDerivedSingleType | LocalName] | arrayType = [EntityDeclaration | LocalName] '[]') name = ID
	  ('(' parameters += DerivedParameter (',' parameters += DerivedParameter)* ')')?
	  "=" expression = Expression
	;

EntityDerivedSingleType
	: PrimitiveDeclaration
	| EntityDeclaration
	;

DerivedParameter
	: type = [PrimitiveDeclaration | LocalName] name = ID "=" default = Expression
	;

EntityRelationDeclaration
	: 'relation' (isRequired ?= 'required'? singleType = [EntityDeclaration | LocalName] | arrayType = [EntityDeclaration | LocalName] '[]') name = ID
	  opposite = Opposite?
	;

Opposite
	: kind = ('opposite-name' | 'opposite-single' | 'opposite-many') name = ID
	;


/****************************
 *	Error
 ****************************/

ErrorDeclaration
	: 'error' name = ID ('extends' extends = [ErrorDeclaration])?
	  BLOCK_START (fields += ErrorField)* BLOCK_END
	;

ErrorField
	: NL+ 'field' isRequired ?= 'required'? type = [PrimitiveDeclaration] name = ID
	  ("=" default = Expression)?
	;

CreateError
	: type=[ErrorDeclaration] ('(' (parameters+=ThrowParameter (',' parameters+=ThrowParameter)*)? ')')?
	;

ThrowParameter:
    name=ID '=' expession=Expression;



/****************************
 *	Datatype
 ****************************/

    
DataTypeDeclaration
    : 'type'
      (
		  primitive = 'boolean' name = ID
		| primitive = 'binary' name = ID (mimeTypes = ModifierMimeTypes? & maxFileSize = ModifierMaxFileSize?) 
		| primitive = 'string' name = ID (maxLength = ModifierMaxLength & regex = ModifierRegex?)
		| primitive = 'numeric' name = ID (precision = ModifierPrecision & scale = ModifierScale)
		| primitive = 'date' name = ID
		| primitive = 'time' name = ID
		| primitive = 'timestamp' name = ID
      )
    ;

EnumDeclaration
    : 'enum' name = ID
      BLOCK_START (literals += EnumLiteral)+ BLOCK_END
    ;

EnumLiteral
    : NL+ name = ID '=' value = INTEGER
    ;

ModifierMaxLength
	: 'max-length' maxLength = INTEGER
	;

ModifierRegex
	: 'regex' regex = StringLiteral
	;

ModifierPrecision
	: 'precision' precision = INTEGER
	;

ModifierScale
	: 'scale' scale = INTEGER
	;


ModifierMimeTypes
	: 'mime-types' mimeTypes+=MIME_TYPE (',' mimeTypes += MIME_TYPE)*
	;

ModifierMaxFileSize
	: 'max-file-size' maxFileSize = INTEGER
	;
	

/****************************
 *	Expression
 ***************************/

Expression returns Expression hidden(WS, CONT_NL, SL_COMMENT, ML_COMMENT)
	: SwitchExpression
	;

MultilineExpression returns Expression hidden(WS, NL, CONT_NL, SL_COMMENT, ML_COMMENT)
	: SwitchExpression
	;

// right associative rule
SwitchExpression returns Expression
	: ImpliesExpression (=> ({TernaryOperation.condition=current} '?')
	  thenExpression=SwitchExpression ':'
      elseExpression=SwitchExpression)?
    ;

ImpliesExpression returns Expression
	: OrExpression (=> ({BinaryOperation.leftOperand=current} operator='implies') rightOperand=OrExpression)*
	;

OrExpression returns Expression
	: XorExpression (=> ({BinaryOperation.leftOperand=current} operator='or') rightOperand=XorExpression)*
	;

XorExpression returns Expression
	: AndExpression (=> ({BinaryOperation.leftOperand=current} operator='xor') rightOperand=AndExpression)*
	;

AndExpression returns Expression
	: EqualityExpression (=> ({BinaryOperation.leftOperand=current} operator='and') rightOperand=EqualityExpression)*
	;

EqualityExpression returns Expression
	: RelationalExpression (=> ({BinaryOperation.leftOperand=current} operator=('!='|'==')) rightOperand=RelationalExpression)*
	;

RelationalExpression returns Expression
	: AdditiveExpression (=> ({BinaryOperation.leftOperand=current} operator=('>=' | '<=' | '>' | '<')) rightOperand=AdditiveExpression)*
	;

AdditiveExpression returns Expression
	: MultiplicativeExpression (=> ({BinaryOperation.leftOperand=current} operator=('+'|'-')) rightOperand=MultiplicativeExpression)*
	;

MultiplicativeExpression returns Expression
	: ExponentExpression (=> ({BinaryOperation.leftOperand=current} operator=('*' | '/' | 'div' | 'mod')) rightOperand=ExponentExpression)*
	;

ExponentExpression returns Expression
	: SpawnOperation (=> ({BinaryOperation.leftOperand=current} operator='^') rightOperand=SpawnOperation)*
	;

SpawnOperation returns Expression
	: UnaryOperation (=> ({SpawnOperation.operand=current} 'as' type=LocalName))?
	;

UnaryOperation returns Expression
	: {UnaryOperation} operator=('not' | '-') operand=FunctionedExpression
    | FunctionedExpression
    ;

FunctionedExpression returns Expression
	: NavigationExpression ({FunctionedExpression.operand=current} functionCall=FunctionCall)?
	;

NavigationExpression returns Expression
	: PrimaryExpression ({NavigationExpression.base=current} features+=Feature+)?
    | NavigationBase
    ;

// enums as separate literals cause problems with completion and script
NavigationBase returns NavigationExpression
	: {NavigationExpression} qName=LocalName (features+=Feature* | '#' enumValue = ID)
	;

FunctionCall
	: {FunctionCall} '!' function=Function features+=Feature* call=FunctionCall?
	;

Feature
	: {Feature} '.' name=ID ('(' parameters+=QueryParameter (',' parameters+=QueryParameter)* ')')?
	;

QueryParameter
	: name = ID '=' expression=MultilineExpression
	;

ParenthesizedExpression returns Expression
	: {ParenthesizedExpression} '(' =>expression = MultilineExpression ')'
	;

PrimaryExpression returns Expression
	: ParenthesizedExpression
	| CreateExpression
	| Literal
	| Self
	;

// Warning: create statement is not allowed in getter!

CreateExpression returns Expression
	: {CreateExpression} 'new'? type=[ClassDeclaration]
	  (   '(' (assignments+=CreateParameter (',' assignments+=CreateParameter)*)? ')'
	  	| '[' (creates += MultilineExpression (',' creates += MultilineExpression)*)? ']'
	  )
	;

CreateParameter:
    name=ID '=' right=MultilineExpression;

Function returns Function
	: name=ID '(' (lambdaArgument=ID '|')? (parameters+=FunctionParameter (',' parameters+=FunctionParameter)*)? ')'
    ;

FunctionParameter
	: {FunctionParameter} expression=MultilineExpression
	;

Literal returns Expression
	: BooleanLiteral
	| NumberLiteral
	| StringLiteral
	| TemporalLiteral
	;

BooleanLiteral returns Expression
	: {BooleanLiteral} ('false' | isTrue?='true')
	;

NumberLiteral returns Expression
	: {IntegerLiteral} value=INTEGER
	| {DecimalLiteral} value=DECIMAL
	;

StringLiteral returns Expression
	: {EscapedStringLiteral} value=STRING
	| {RawStringLiteral} value=RAW_STRING
	;

TemporalLiteral returns Expression
	: {DateLiteral} value=DATE
	| {TimeStampLiteral} value=TIMESTAMP
	| {TimeLiteral} value=TIME
	;

Self returns Expression
	: {Self} 'self'
	;

LocalName
	: (ID '::')? ID
    ;

ModelName
	: ID('::' ID)*
    ;

/****************************
 *	Terminals
 ****************************/

BLOCK_START
	: NL* '{'
	;

BLOCK_END
	: NL* '}'
	;


terminal TIMESTAMP
	: '`' DIGIT+ '-' DIGIT DIGIT '-' DIGIT DIGIT 'T' DIGIT DIGIT ':' DIGIT DIGIT (':' DIGIT DIGIT ('.' DIGIT+ )? )? ('Z' | ('+' | '-') DIGIT DIGIT ':' DIGIT DIGIT )'`'
	;

terminal TIME
	: '`' DIGIT DIGIT ':' DIGIT DIGIT (':' DIGIT DIGIT ('.' DIGIT+ )? )? '`'
	;

terminal DATE
	: '`' DIGIT+ '-' DIGIT DIGIT '-' DIGIT DIGIT '`'
	;

terminal DIGIT
	: '0'..'9'
	;

terminal DECIMAL returns ecore::EBigDecimal
	: INTEGER '.' INTEGER
	;

terminal INTEGER returns ecore::EBigInteger
	: ('0'..'9')+
	;

terminal ID
	: '\\'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*
	;

terminal STRING
	: '"' ('\\' ('b'|'t'|'n'|'f'|'r'|'"'|'\\') | !('\\' | '"' | '\n' | '\r'))* '"'
	;

terminal RAW_STRING
	: 'r"' (!('"' | '\n' | '\r'))* '"'
	;

terminal MIME_TYPE
    : 'm"' ('a'..'z' | 'A'..'Z')+ '/' ('*' | ('a'..'z' | 'A'..'Z')+ ('.' ('a'..'z' | 'A'..'Z')+)* ) '"'
	;

terminal CONT_NL
	: '\\' (' ' | '\t')* '\r'? '\n'
	;
 
terminal ML_COMMENT
	: '/*'->'*/'
	;

terminal SL_COMMENT
	: '//' !('\n' | '\r')*
	;

terminal WS
	: (' ' | '\t')+
	;

terminal NL
	: '\r' | '\n' | ';'
	;

terminal ANY_OTHER
	: .
	;
