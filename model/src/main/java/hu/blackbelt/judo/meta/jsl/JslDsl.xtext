grammar hu.blackbelt.judo.meta.jsl.JslDsl hidden(WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate jsldsl "http://www.blackbelt.hu/judo/meta/jsl/JslDsl"
 
ModelDeclaration returns ModelDeclaration
    : {ModelDeclaration}
      annotations += AnnotationMark*
      'model' name = ModelName SC+
      imports += ModelImportDeclaration*
	  (declarations += Declaration)*
    ;

JSLID : ID | 'boolean' | 'binary' | 'string' | 'numeric' | 'date' | 'time' | 'timestamp'
	       | 'regex' | 'precision' | 'scale'
	       | 'model' | 'import' | 'entity' | 'transfer' | 'query' | 'type' | 'enum' | 'function' | 'lambda'
	       | 'field' | 'identifier' | 'derived' | 'relation' | 'constraint' | 'error'
	       | 'required' | 'as' | 'abstract' | 'extends' | 'exports' | 'opposite' | 'on' | 'onerror'
	       | 'collection' | 'declaration' | 'constant'
	       | 'implies' | 'or' | 'xor' | 'and' | 'div' | 'mod' 
	       | 'kB' | 'MB' | 'GB' | 'KiB' | 'MiB' | 'GiB'
	       | 'view' | 'widget' | 'action' | 'table' | 'row' | 'column'
	       | 'caption' | 'icon' | 'enabled' | 'hidden' | 'width' | 'height'
	       | 'group' | 'tab' | 'horizontal' | 'vertical' | 'frame' | 'left' | 'right' | 'center' | 'top' | 'bottom' | 'stretch'
	       | 'service' | 'choices' | 'guard'
	       | 'actor' | 'claim'
	       
	       // 'reads', 'maps' are not included
	       // 'self', 'true', 'false', 'not' are not included
	;

ModelImportDeclaration 
    : 'import' model = [ModelDeclaration | ModelName] ('as' alias = JSLID)? SC+
	;

Declaration
	: (TypeDeclaration
	| ErrorDeclaration
	| QueryDeclaration
	| FunctionDeclaration
	| LambdaDeclaration
	| AnnotationDeclaration)
	  SC*
	;


TypeDeclaration
	: PrimitiveDeclaration
	| ClassDeclaration
	;

PrimitiveDeclaration
	: EnumDeclaration
	| DataTypeDeclaration
    ;

ClassDeclaration
	: EntityDeclaration
//	| ControlDeclaration
	| ServiceDeclaration
	| TransferDeclaration
	| ViewDeclaration
	| RowDeclaration
	| ActorDeclaration
	;

/****************************
 *	Entity
 ****************************/
fragment Named
	: name = JSLID;

fragment Cardinality
    : isMany ?= '[]'
    ;

EntityDeclaration
	: {EntityDeclaration}
	  annotations += AnnotationMark*
	  'entity' isAbstract ?= 'abstract'? Named
	  ('extends' extends += [EntityDeclaration | ModelName] (',' extends += [EntityDeclaration | ModelName])*)?
	  (SC | BLOCK_START (members += EntityMemberDeclaration)* BLOCK_END)
	;


QueryDeclaration
	: 'query' (referenceType = [SingleType | ModelName] Cardinality?) Named
	  ('(' (parameters += QueryParameterDeclaration (',' parameters += QueryParameterDeclaration)*)? ')')
	  "=>" expression = Expression
	  SC
	;

EntityMemberDeclaration
	: (EntityFieldDeclaration
	| EntityIdentifierDeclaration
	| EntityRelationDeclaration
	| EntityDerivedDeclaration
	| EntityQueryDeclaration
	| EntityOperationDeclaration
//	| ConstraintDeclaration
	)
	  SC*
	;

EntityFieldDeclaration
	: annotations += AnnotationMark*
	  'field' (isRequired ?= 'required'? referenceType = [SingleType | ModelName] Cardinality?) Named
	  ('=' defaultExpression = Expression)? SC
	;

EntityIdentifierDeclaration
	: annotations += AnnotationMark*
	  'identifier' isRequired ?= 'required'? referenceType = [PrimitiveDeclaration | ModelName] Named
	  ('=' defaultExpression = Expression)? SC
	;

SingleType 
	: PrimitiveDeclaration
	| EntityDeclaration
	;


EntityDerivedDeclaration
	: annotations += AnnotationMark*
	  'derived' (referenceType = [SingleType | ModelName] Cardinality?) Named
	  "=>" expression = Expression SC
	;

EntityQueryDeclaration
	: annotations += AnnotationMark*
	  'query' (referenceType = [SingleType | ModelName] Cardinality?) Named
	  ('(' (parameters += QueryParameterDeclaration (',' parameters += QueryParameterDeclaration)*)? ')')
	  "=>" expression = Expression SC
	;
 
QueryParameterDeclaration
	: referenceType = [PrimitiveDeclaration | ModelName] Named ("=" default = Literal)?
	;

EntityRelationDeclaration
	: annotations += AnnotationMark*
	  'relation' (isRequired ?= 'required'? referenceType = [EntityDeclaration | ModelName] Cardinality?) Named
	  opposite = EntityRelationOpposite? SC
	;

EntityRelationOpposite
	: EntityRelationOppositeInjected
	| EntityRelationOppositeReferenced
	;

EntityRelationOppositeInjected
	: 'opposite-add' Named Cardinality?
	;

EntityRelationOppositeReferenced
	: 'opposite' oppositeType = [EntityRelationDeclaration | LocalName]
	;

EntityOperationDeclaration
	: annotations += AnnotationMark*
	  'operation' static ?= 'static'? ('void'? | return = EntityOperationReturnDeclaration) Named
	  ('(' (parameters += EntityOperationParameterDeclaration (',' parameters += EntityOperationParameterDeclaration)*)? ')')
	  (SC | BLOCK_START BLOCK_END )
	;

EntityOperationReturnDeclaration
	: referenceType = [SingleType | ModelName] Cardinality?
	;

EntityOperationParameterDeclaration
	: referenceType = [SingleType | ModelName] Cardinality? Named
	;


/****************************
 *	Service
 ****************************/

ServiceDeclaration
	: {ServiceDeclaration}
	  annotations += AnnotationMark*
	  'service' Named
	  map = EntityMapDeclaration?
	  ('guard' guard = Expression)?
	  (SC | BLOCK_START (members += ServiceMemberDeclaration)* BLOCK_END)
	;

EntityMapDeclaration
	: '(' entity = [EntityDeclaration | ModelName] Named ')'  // if no name defined, the 'self' shall be default name
	| 'maps' entity = [EntityDeclaration | ModelName] 'as' Named
	;


ServiceMemberDeclaration
	: ServiceOperationDeclaration
	  SC*
	;

ServiceOperationDeclaration
	: ServiceDataDeclaration
	| ServiceFunctionDeclaration
	;

ServiceDataDeclaration
	: annotations += AnnotationMark*
	  'function' return = ServiceReturnDeclaration Cardinality? Named '=>' expression = Expression
	  (('guard' guard = Expression)? & ('choices' choices = Expression)?)SC
	;

ServiceFunctionDeclaration
	: annotations += AnnotationMark*
	  'function'
	  ('void'? | return = ServiceReturnDeclaration | alternateReturn = ServiceReturnAlternateDeclaration) Named
	  '(' parameter = ServiceFunctionParameterDeclaration? ')'
	  ('guard' guard = Expression)?
	  (automapping ?= SC | BLOCK_START BLOCK_END )
	;

ServiceReturnAlternateDeclaration
	: '<' referenceTypes += ServiceReturnDeclaration ("|" referenceTypes += ServiceReturnDeclaration)+ '>'
	;

ServiceReturnDeclaration
	: referenceType = [Transferable | ModelName]
	;

ServiceFunctionParameterDeclaration
	: referenceType = [Transferable | ModelName] Named?
	;

Transferable
	: TransferDeclaration
	| ViewDeclaration
	| RowDeclaration
	;

/****************************
 *	Transfer
 ****************************/

TransferDeclaration
	: {TransferDeclaration}
	  annotations += AnnotationMark*
	  'transfer' Named
	  map = EntityMapDeclaration?
	  ('exports' exports += [ServiceDeclaration | ModelName] (',' exports += [ServiceDeclaration | ModelName])*)?
	  (automap ?= SC | BLOCK_START (members += TransferMemberDeclaration)* BLOCK_END)
	;

TransferMemberDeclaration
	: TransferFieldDeclaration
	  SC*
	;

TransferFieldDeclaration
	: annotations += AnnotationMark*
	  'field' (required ?= 'required'? referenceType = [TransferFieldType | ModelName] Cardinality?) Named
	  ("=" default = Expression)? ('maps' maps = Expression | 'reads' reads = Expression)?
	  SC
	;

TransferFieldType
	: PrimitiveDeclaration
	| TransferDeclaration
	;

/****************************
 *	View
 ****************************/

ViewDeclaration
	: {ViewDeclaration}
	  annotations += AnnotationMark*
	  'view' Named
	  map = EntityMapDeclaration?
	  ('exports' exports += [ServiceDeclaration | ModelName] (',' exports += [ServiceDeclaration | ModelName])*)?
	  (automap ?= SC | BLOCK_START (members += ViewMemberDeclaration)* BLOCK_END)
	;

ViewMemberDeclaration
	: ViewWidgetDeclaration
	| ViewTableDeclaration
	| ViewGroupDeclaration
	| ViewTabDeclaration
	| ViewActionDeclaration
	  SC*
	;

ViewTabDeclaration
	: annotations += AnnotationMark*
	 'tab' Named
	  (caption = ViewCaptionModifier? & icon = ViewIconModifier? & enabled = ViewEnabledModifier? & ^hidden = ViewHiddenModifier? & width = ViewWidthModifier? & frame = ViewFrameModifier?)
	  BLOCK_START (members += ViewGroupDeclaration)* BLOCK_END
	;

ViewGroupDeclaration
	: annotations += AnnotationMark*
	  'group' Named
	  (caption = ViewCaptionModifier? & icon = ViewIconModifier? & enabled = ViewEnabledModifier? & ^hidden = ViewHiddenModifier? & width = ViewWidthModifier? & horizontal = ViewHorizontalModifier? & vertical = ViewVerticalModifier? & frame = ViewFrameModifier?)
	  BLOCK_START (members += ViewMemberDeclaration)* BLOCK_END
	;

ViewWidgetDeclaration
	: annotations += AnnotationMark*
	  'widget' (referenceType = [PrimitiveDeclaration | ModelName]) Named
	  "=" expression = Expression
	  (caption = ViewCaptionModifier? & icon = ViewIconModifier? & enabled = ViewEnabledModifier? & ^hidden = ViewHiddenModifier? & width = ViewWidthModifier? & height = ViewHeightModifier?)
	  SC
	;

ViewTableDeclaration
	: annotations += AnnotationMark*
	  'table' (referenceType = [RowDeclaration | ModelName]) '[]' Named
	  "=" expression = Expression
	  (caption = ViewCaptionModifier? & icon = ViewIconModifier? & enabled = ViewEnabledModifier? & ^hidden = ViewHiddenModifier? & width = ViewWidthModifier? & height = ViewHeightModifier?)
	  SC
	;

ViewActionDeclaration
	: annotations += AnnotationMark*
	  'action' Named
	  ('function' function = ServiceFunctionCall & caption = ViewCaptionModifier? & icon = ViewIconModifier? & enabled = ViewEnabledModifier? & ^hidden = ViewHiddenModifier? & width = ViewWidthModifier?)
	  SC
	;

ViewCaptionModifier
	: 'caption' expression = Expression
	;

ViewIconModifier
	: 'icon' name = StringLiteral
	;	

ViewFrameModifier
	: 'frame' expression = Expression
	;	
	
ViewEnabledModifier
	: 'enabled' expression = Expression
	;

ViewHiddenModifier
	: 'hidden' expression = Expression
	;

ViewWidthModifier
	: 'width' expression = Expression
	;

ViewHeightModifier
	: 'height' expression = Expression
	;

ViewHorizontalModifier
	: 'horizontal' (left ?= 'left' | right ?= 'right' | center ?= 'center')
	;

ViewVerticalModifier
	: 'vertical' (top ?= 'top' | bottom ?= 'bottom' | center ?= 'center' | stretch = 'stretch')
	;

ServiceFunctionCall
	: declaration = [ServiceFunctionDeclaration | ModelName] '(' argument = Expression? ')'
	;

/****************************
 *	Row
 ****************************/

RowDeclaration
	: {RowDeclaration}
	  annotations += AnnotationMark*
	  'row' Named
	  map = EntityMapDeclaration?
	  ('exports' exports += [ServiceDeclaration | ModelName] (',' exports += [ServiceDeclaration | ModelName])*)?
	  (automap ?= SC | BLOCK_START (members += RowMemberDeclaration)* BLOCK_END)
	;

RowMemberDeclaration
	: RowColumnDeclaration
	| RowActionDeclaration
	  SC*
	;

RowColumnDeclaration
	: annotations += AnnotationMark*
	  'column' (referenceType = [PrimitiveDeclaration | ModelName]) Named
	  "=" expression = Expression
	  SC
	;

RowActionDeclaration
	: annotations += AnnotationMark*
	  'action' Named 'function' function = ServiceFunctionCall
	  SC
	;

/****************************
 *	Actor
 ****************************/

ActorDeclaration
	: {ActorDeclaration}
	  annotations += AnnotationMark*
	  'actor' Named
	  map = EntityMapDeclaration?
	  ('exports' exports += [ServiceDeclaration | ModelName] (',' exports += [ServiceDeclaration | ModelName])*)?
	  (('realm' realm = StringLiteral)? & ('claim' claim = StringLiteral)? & ('identity' identity = Expression)? & ('guard' guard = Expression)?)
	  SC
	;

/****************************
 *	Datatype
 ****************************/

DataTypeDeclaration
    : annotations += AnnotationMark*
      'type'
      (
		  primitive = 'boolean' Named
		| primitive = 'binary' Named '(' mimeTypes = ModifierMimeTypes ',' maxFileSize = ModifierMaxFileSize ')'
		| primitive = 'string' Named '(' minSize = ModifierMinSize ',' maxSize = ModifierMaxSize (',' regex = ModifierRegex)? ')'
		| primitive = 'numeric' Named '(' precision = ModifierPrecision ',' scale = ModifierScale ')'
		| primitive = 'date' Named
		| primitive = 'time' Named
		| primitive = 'timestamp' Named
      ) SC
    ;


/****************************
 *	Enum
 ****************************/

EnumDeclaration
    : annotations += AnnotationMark*
      'enum' Named
      BLOCK_START (literals += EnumLiteral)* BLOCK_END
    ;

EnumLiteral
    : annotations += AnnotationMark*
      Named '=' value = Integer SC+
    ;


ModifierMinSize
	: 'min-size' '=' value = Integer
	;

ModifierMaxSize
	: 'max-size' '=' value = Integer
	;

ModifierRegex
	: 'regex' '=' regex = StringLiteral
	;

ModifierPrecision
	: 'precision' '=' value = Integer
	;

ModifierScale
	: 'scale' '=' value = Integer
	;

ModifierMimeTypes
	: 'mime-types' '=' '[' values += MimeType (',' values += MimeType)* ']'
	;

MimeType
	: value = StringLiteral
	;

ModifierMaxFileSize
	: 'max-file-size' '=' numeric = Integer (unit = DataUnit)?
	;
	
enum DataUnit
	: KB = 'kB'
	| MB = 'MB'
	| GB = 'GB'
	| KiB = 'KiB'
	| MiB = 'MiB'
	| GiB = 'GiB'
	;

/****************************
 *	Expression
 ***************************/

Expression returns Expression:
    SwitchExpression;

SwitchExpression returns Expression
	: ImpliesExpression (=> ({TernaryOperation.condition=current} '?')
	  thenExpression=SwitchExpression ':'
      elseExpression=SwitchExpression)?
    ;

ImpliesExpression returns Expression
	: OrExpression (=> ({BinaryOperation.leftOperand=current} operator='implies') rightOperand=OrExpression)*
	;

OrExpression returns Expression
	: XorExpression (=> ({BinaryOperation.leftOperand=current} operator='or') rightOperand=XorExpression)*
	;

XorExpression returns Expression
	: AndExpression (=> ({BinaryOperation.leftOperand=current} operator='xor') rightOperand=AndExpression)*
	;

AndExpression returns Expression
	: EqualityExpression (=> ({BinaryOperation.leftOperand=current} operator='and') rightOperand=EqualityExpression)*
	;

EqualityExpression returns Expression
	: RelationalExpression (=> ({BinaryOperation.leftOperand=current} operator=('!='|'==')) rightOperand=RelationalExpression)*
	;

RelationalExpression returns Expression
	: AdditiveExpression (=> ({BinaryOperation.leftOperand=current} operator=('>=' | '<=' | '>' | '<')) rightOperand=AdditiveExpression)*
	;

AdditiveExpression returns Expression
	: MultiplicativeExpression (=> ({BinaryOperation.leftOperand=current} operator=('+'|'-')) rightOperand=MultiplicativeExpression)*
	;

MultiplicativeExpression returns Expression
	: ExponentExpression (=> ({BinaryOperation.leftOperand=current} operator=('*' | '/' | 'div' | 'mod')) rightOperand=ExponentExpression)*
	;

ExponentExpression returns Expression
	: UnaryOperation (=> ({BinaryOperation.leftOperand=current} operator='^') rightOperand=UnaryOperation)*
	;
 
UnaryOperation returns Expression
	: {UnaryOperation} operator='not' operand=UnaryOperation
	| Navigation
    ;

Navigation returns Expression
	: {Navigation} base = NavigationBase (features += Feature)*
	;

NavigationBase
	: Self
	| Parentheses
	| NavigationBaseDeclarationReference
	| QueryCall
	| Literal
	;

Self
	: isSelf ?= 'self'		
	;

Parentheses
	: '(' => expression = Expression ')'		
	;
 
NavigationBaseDeclarationReference
	: {NavigationBaseDeclarationReference} reference = [NavigationBaseDeclaration | ModelName]
 	;
 
NavigationBaseDeclaration
	: EntityDeclaration
	| LambdaVariable
	| QueryParameterDeclaration
	| PrimitiveDeclaration
	| EntityMapDeclaration
	;

QueryCall
	: declaration = [QueryDeclaration | ModelName ] '(' (arguments += QueryArgument (',' arguments += QueryArgument)*)? ')'
	;

Feature
	: MemberReference
	| Call
	;

MemberReference
    : '.' member = [NavigationTarget | LocalName]
    ;

Call
	: EntityQueryCall
	| FunctionCall
	| LambdaCall
	;

EntityQueryCall
	: '.' declaration = [EntityQueryDeclaration | LocalName ] => '(' (arguments += QueryArgument (',' arguments += QueryArgument)*)? ')'
	;

FunctionCall
	: '!' declaration = [FunctionDeclaration | LocalName ] '(' (arguments += FunctionArgument (',' arguments += FunctionArgument)*)? ')'
	;

FunctionArgument
    : declaration = [FunctionParameterDeclaration | LocalName ] '=' expression = Expression
    ;

QueryArgument
    : declaration = [QueryParameterDeclaration | LocalName ] '=' expression = Expression
    ;

LambdaCall
	: '!' declaration = [LambdaDeclaration | LocalName ] '(' variable = LambdaVariable => '|' lambdaExpression = Expression ')';

LambdaVariable
    : {LambdaVariable} Named    	
    ;


/****************************
 *	Function
 ***************************/

FunctionDeclaration
	: 'function' returnType = TypeDescription Named '(' (parameters += FunctionParameterDeclaration (',' parameters += FunctionParameterDeclaration)*)? ')' 'on' baseType = TypeDescription SC
	;

FunctionParameterDeclaration
	: isRequired ?= 'required'? description = TypeDescription Named
	;

TypeDescription
	: {TypeDescription} type = Type
	| collection ?= 'collection' '<' type = Type '>'
	| declaration ?= 'declaration' '<' type = Type '>'
	| constant ?= 'constant' '<' type = Type '>'
	;

Type
	: 'boolean' | 'binary' | 'string' | 'numeric' | 'date' | 'time' | 'timestamp' | 'enum' | 'entity'
	;

LambdaDeclaration 
	: 'lambda' returnType = TypeDescription Named '(' (expressionType = TypeDescription)? ')' SC
	;


/****************************
 *	Annotation
 ***************************/

AnnotationDeclaration
	: 'annotation' Named ('(' (parameters += AnnotationParameterDeclaration (',' parameters += AnnotationParameterDeclaration)*)? ')')?
	  ('on' targets += AnnotationTarget (',' targets += AnnotationTarget)*)?
	  (SC | BLOCK_START annotations += AnnotationMark* BLOCK_END )
	;

AnnotationParameterDeclaration
	: referenceType = AnnotationParameterType Named
	;

AnnotationParameterType
	: type = ('boolean'	| 'string' | 'numeric')
	;

AnnotationTarget
	: model ?= 'model'
	| type ?= 'type'
	| enumeration ?= 'enum'
	| 'enum' '::' enumLiteral ?= 'literal'
	| entity ?= 'entity'
	| 'entity' '::' entityField ?= 'field'
	| 'entity' '::' entityIdentifier ?= 'identifier'
	| 'entity' '::' entityQuery ?= 'query'
	| 'entity' '::' entityRelation ?= 'relation'
	| 'entity' '::' entityDerived ?= 'derived'
	| 'entity' '::' entityOperation ?= 'operation'
	| transfer ?= 'transfer'
	| 'transfer' '::' transferField ?= 'field'
	| service ?= 'service'
	| 'service' '::' serviceFunction ?= 'function'
	| actor ?= 'actor'
	| query ?= 'query'
	;

AnnotationMark
	: '@' declaration = [AnnotationDeclaration | ModelName] ('(' arguments += AnnotationArgument? (',' arguments += AnnotationArgument?)* ')')?
	;

AnnotationArgument
    : declaration = [AnnotationParameterDeclaration | LocalName] '=' (literal = Literal | reference = [AnnotationParameterDeclaration | LocalName])
    ;

EnumLiteralReference
    : {EnumLiteralReference} enumDeclaration = [EnumDeclaration | ModelName] '#' enumLiteral = [EnumLiteral | EnumLiteralName ]    	
    ;

NavigationTarget
    : EntityFieldDeclaration
	| EntityIdentifierDeclaration
	| EntityRelationDeclaration
	| EntityDerivedDeclaration
    | EntityRelationOppositeInjected
    ;

Literal
	: BooleanLiteral
	| NumberLiteral
	| StringLiteral
	| TemporalLiteral
	| EnumLiteralReference
	;

BooleanLiteral
	: {BooleanLiteral} ('false' | isTrue?='true')
	;

NumberLiteral
	: IntegerLiteral
	| DecimalLiteral
	;

IntegerLiteral hidden()
	: (minus ?= "-" | "+")? value=Integer
	;

DecimalLiteral hidden()
	: (minus ?= "-" | "+")? value=Decimal
	;

StringLiteral
	: {EscapedStringLiteral} value=STRING
	| {RawStringLiteral} value=RAW_STRING
	;

TemporalLiteral
	: {DateLiteral} value=DATE
	| {TimeStampLiteral} value=TIMESTAMP
	| {TimeLiteral} value=TIME
	;


 // ************************************
 // For later use
 // ************************************
 
 ConstraintDeclaration
	: 'constraint' Named expression = Expression ('onerror' error = CreateError)? SC
	;

 
/****************************
 *	Error
 ****************************/

ErrorDeclaration
	: 'error' Named ('extends' extends = [ErrorDeclaration | ModelName])?
	  (SC | BLOCK_START (fields += ErrorField)* BLOCK_END)
	;

ErrorField
	: 'field' referenceType = [PrimitiveDeclaration | ModelName] Named
	  ('=' defaultExpression = Expression)? SC+
	;

CreateError
	: errorDeclarationType=[ErrorDeclaration | ModelName] ('(' (parameters+=ThrowParameter (',' parameters+=ThrowParameter)*)? ')')?
	;

ThrowParameter
	: errorFieldType=[ErrorField | LocalName] '=' expession=Literal;


Decimal returns ecore::EBigDecimal
	: NUMBER '.' NUMBER
	;

Integer returns ecore::EBigInteger
	: NUMBER
	;

EnumLiteralName
	: JSLID
    ;

LocalName
	: JSLID
    ;

ModelName
	: JSLID('::' JSLID)*
    ;

/****************************
 *	Terminals
 ****************************/

BLOCK_START
	: '{'
	;

BLOCK_END
	: '}'
	;

terminal fragment DIGIT
	: '0'..'9'
	;

terminal fragment ALPHABET
    : 'a'..'z' | 'A'..'Z'    	
    ;

terminal fragment NEWLINE
    : '\n' | '\r'   	
    ;

terminal TIMESTAMP
	: '`' DIGIT+ '-' DIGIT DIGIT '-' DIGIT DIGIT 'T' DIGIT DIGIT ':' DIGIT DIGIT (':' DIGIT DIGIT ('.' DIGIT+ )? )? ('Z' | ('+' | '-') DIGIT DIGIT ':' DIGIT DIGIT )'`'
	;

terminal TIME
	: '`' DIGIT DIGIT ':' DIGIT DIGIT (':' DIGIT DIGIT ('.' DIGIT+ )? )? '`'
	;

terminal DATE
	: '`' DIGIT+ '-' DIGIT DIGIT '-' DIGIT DIGIT '`'
	;
 
terminal NUMBER
	: DIGIT+
	;

terminal ID
	: ALPHABET (ALPHABET | DIGIT)* | '`' ALPHABET (ALPHABET | DIGIT)* '`'
	;

terminal STRING
	: '"' ('\\' ('t'|'n'|'f'|'r'|'"'|'\\') | !('\\' | '"' | NEWLINE))* '"'
	;

terminal RAW_STRING
	: 'r"' (!('"' | NEWLINE))* '"'
	;
 
terminal ML_COMMENT
	: '/*'->'*/'
	;

terminal SL_COMMENT
	: '//' !(NEWLINE)*
	;

terminal SC
	: ';'
	;

terminal WS
	: (' '|'\t'|'\r'|'\n')+
	;
