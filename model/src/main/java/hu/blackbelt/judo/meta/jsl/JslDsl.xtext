grammar hu.blackbelt.judo.meta.jsl.JslDsl hidden(WS, NL, SL_COMMENT, ML_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate jsldsl "http://www.blackbelt.hu/judo/meta/jsl/JslDsl"

 
ModelDeclaration returns ModelDeclaration hidden(WS, SL_COMMENT, ML_COMMENT)
    : {ModelDeclaration} 'model' name = ModelName
      imports += ModelImport*
	  (declarations += Declaration)*
	  NL*
    ;

JslID : ID 
	| 'import' | 'as' | 'entity' | 'extends' | 'abstract' | 'query' | 'field' | 'required' 	
	| 'constraint' 
	| 'offset' | 'pattern' | 'replacement' | 'millisecond'
	//| 'implies' | 'or' | 'xor' | 'and' | 'div' | 'mod' | 'not'
	| 'onerror' | 'identifier' | 'derived' | 'relation' | 'opposite' | 'opposite-add' | 'error' | 'type'
	| 'binary' |'string' | 'numeric' | 'timestamp' | 'mime-types' | 'max-file-size'
	| 'enum' | 'regex' | 'precision' | 'scale' | 'max-length' 
	| 'date' | 'time' | 'asMilliseconds' | 'fromMilliseconds' | 'plusMilliseconds'
    | 'plusSeconds' | 'plusMinutes' | 'plusHours' | 'plusDays'
    | 'plusMonths' | 'plusYears' | 'of' 
    | 'typeOf' | 'kindOf' | 'container' | 'asType' | 'memberOf' 
    | 'head' | 'tail' | 'any' | 'count' 
    | 'asCollection' | 'contains' | 'filter' | 'anyTrue' | 'allTrue' 
	| 'min' | 'max' | 'avg' | 'sum'
    | 'getVariable' | 'isDefined' | 'isUnDefined' | 'length' | 'first' | 'last' | 'position' | 'substring' | 'lower' | 'upper' | 'capitalize'
    | 'matches' | 'like' | 'ilike' | 'replace' | 'trim' | 'rtrim' | 'ltrim' | 'round' | 'floor' | 'ceil' | 'abs' | 'asString' 
    | 'year' | 'month' | 'day'
    ;


ModelImport
    : NL+ 'import' modelName = ModelImportDeclaration
	;

ModelImportDeclaration
    : importName = ModelName ('as' alias = JslID)?
	;

Declaration
	: NL+ (TypeDeclaration
	| ErrorDeclaration
	| QueryDeclaration )
	;

TypeDeclaration
	: PrimitiveDeclaration
	| ClassDeclaration
	;

PrimitiveDeclaration
	: EnumDeclaration
	| DataTypeDeclaration
    ;

ClassDeclaration
	: EntityDeclaration
	;

/****************************
 *	Entity
 ****************************/
fragment Named
	: name = JslID;

fragment Cardinality
    : isMany ?= '[]'
    ;

EntityDeclaration
	: {EntityDeclaration}
	  'entity' isAbstract ?= 'abstract'? Named
	  ('extends' extends += [EntityDeclaration | LocalName] (',' extends += [EntityDeclaration | LocalName])*)?
	  BLOCK_START (members += EntityMemberDeclaration)* BLOCK_END
	;


QueryDeclaration
	: 'query' (referenceType = [SingleType | LocalName] Cardinality?) Named
	  ('(' parameters += QueryDeclarationParameter (',' parameters += QueryDeclarationParameter)* ')')
	  "=>" expression = Expression
	;

EntityMemberDeclaration
	: NL+ (EntityFieldDeclaration
	| EntityIdentifierDeclaration
	| EntityRelationDeclaration
	| EntityDerivedDeclaration
	| EntityQueryDeclaration
	| ConstraintDeclaration)
	;

ConstraintDeclaration
	: 'constraint' Named expression = Expression ('onerror' error = CreateError)?
	;

EntityFieldDeclaration
	: ('field')? (isRequired ?= 'required'? referenceType = [SingleType | LocalName] Cardinality?) Named
	  (defaultExpression = DefaultExpressionType)?
	;


DefaultExpressionType
	: {DefaultExpressionType} '=' expression = (
		Literal 
		| EnumLiteralReference 
		| NavigationBase 
		| ParenthesizedExpression
		| CreateExpression
	)
	;

SingleType 
	: PrimitiveDeclaration
	| EntityDeclaration
	;

EntityIdentifierDeclaration
	: 'identifier' isRequired ?= 'required'? referenceType = [PrimitiveDeclaration | LocalName] Named
	  (defaultExpression = DefaultExpressionType)?
	;

EntityDerivedDeclaration
	: 'derived' (referenceType = [SingleType | LocalName] Cardinality?) Named
	  "=>" expression = Expression
	;

EntityQueryDeclaration
	: 'query' (referenceType = [EntityQueryTargetType | LocalName] Cardinality?) Named
	  ('(' parameters += QueryDeclarationParameter (',' parameters += QueryDeclarationParameter)* ')')
	  "=>" expression = Expression
	;

EntityQueryTargetType
	: PrimitiveDeclaration
	| EntityDeclaration
	;

QueryDeclarationParameter
	: referenceType = [PrimitiveDeclaration | LocalName] Named "=" default = Literal
	;

EntityRelationDeclaration
	: 'relation' (isRequired ?= 'required'? referenceType = [EntityDeclaration | LocalName] Cardinality?) Named
	  opposite = EntityRelationOpposite?
	;

EntityRelationOpposite
	: 'opposite-add' oppositeName = JslID Cardinality?
	| 'opposite' oppositeType = [EntityRelationDeclaration | LocalName]
	;


/****************************
 *	Error
 ****************************/

ErrorDeclaration
	: 'error' Named ('extends' extends = [ErrorDeclaration])?
	  BLOCK_START (fields += ErrorField)* BLOCK_END
	;

ErrorField
	: NL+ 'field' isRequired ?= 'required'? referenceType = [PrimitiveDeclaration | LocalName] Named
	  (defaultExpression = DefaultExpressionType)?
	;

CreateError
	: errorDeclarationType=[ErrorDeclaration | LocalName] ('(' (parameters+=ThrowParameter (',' parameters+=ThrowParameter)*)? ')')?
	;

ThrowParameter
	: errorFieldType=[ErrorField | LocalName] '=' expession=Literal;



/****************************
 *	Datatype
 ****************************/

    
DataTypeDeclaration
    : 'type'
      (
		  BooleanPrimitive
		| BinaryPrimitive ('(' (mimeTypes = ModifierMimeTypes? & (',' maxFileSize = ModifierMaxFileSize))? ')')?
		| StringPrimitive ('('(maxLength = ModifierMaxLength & (',' regex = ModifierRegex)?) ')')?
		| NumericPrimitive ('('(precision = ModifierPrecision & (',' scale = ModifierScale)) ')')?
		| DatePrimitive
		| TimePrimitive
		| TimestampPrimitive
      )
    ;

BooleanPrimitive returns DataTypeDeclaration: primitive = 'boolean' Named;
BinaryPrimitive returns DataTypeDeclaration : primitive = 'binary' Named;
StringPrimitive returns DataTypeDeclaration : primitive = 'string' Named;
NumericPrimitive returns DataTypeDeclaration : primitive = 'numeric' Named;
DatePrimitive returns DataTypeDeclaration : primitive = 'date' Named;
TimePrimitive returns DataTypeDeclaration : primitive = 'time' Named;
TimestampPrimitive returns DataTypeDeclaration : primitive = 'timestamp' Named;



/****************************
 *	Enum
 ****************************/

EnumDeclaration
    : 'enum' Named
      BLOCK_START (literals += EnumLiteral)+ BLOCK_END
    ;

EnumLiteral
    : NL+ Named '=' value = INTEGER
    ;


ModifierMaxLength
	: 'max-length' '=' value = INTEGER
	;

ModifierRegex
	: 'regex' '=' regex = StringLiteral
	;

ModifierPrecision
	: 'precision' '=' value = INTEGER
	;

ModifierScale
	: 'scale' '=' value = INTEGER
	;


ModifierMimeTypes
	: 'mime-types' '=' values+=MIME_TYPE (',' values += MIME_TYPE)*
	;

ModifierMaxFileSize
	: 'max-file-size' '=' value = INTEGER
	;
	

/****************************
 *	Expression
 ***************************/

Expression returns Expression hidden(WS, CONT_NL, SL_COMMENT, ML_COMMENT)
	: SwitchExpression
	;

MultilineExpression returns Expression hidden(WS, NL, CONT_NL, SL_COMMENT, ML_COMMENT)
	: SwitchExpression
	;

// right associative rule
SwitchExpression returns Expression
	: ImpliesExpression (=> ({TernaryOperation.condition=current} '?')
	  thenExpression=SwitchExpression ':'
      elseExpression=SwitchExpression)?
    ;

ImpliesExpression returns Expression
	: OrExpression (=> ({BinaryOperation.leftOperand=current} operator='implies') rightOperand=OrExpression)*
	;

OrExpression returns Expression
	: XorExpression (=> ({BinaryOperation.leftOperand=current} operator='or') rightOperand=XorExpression)*
	;

XorExpression returns Expression
	: AndExpression (=> ({BinaryOperation.leftOperand=current} operator='xor') rightOperand=AndExpression)*
	;

AndExpression returns Expression
	: EqualityExpression (=> ({BinaryOperation.leftOperand=current} operator='and') rightOperand=EqualityExpression)*
	;

EqualityExpression returns Expression
	: RelationalExpression (=> ({BinaryOperation.leftOperand=current} operator=('!='|'==')) rightOperand=RelationalExpression)*
	;

RelationalExpression returns Expression
	: AdditiveExpression (=> ({BinaryOperation.leftOperand=current} operator=('>=' | '<=' | '>' | '<')) rightOperand=AdditiveExpression)*
	;

AdditiveExpression returns Expression
	: MultiplicativeExpression (=> ({BinaryOperation.leftOperand=current} operator=('+'|'-')) rightOperand=MultiplicativeExpression)*
	;

MultiplicativeExpression returns Expression
	: ExponentExpression (=> ({BinaryOperation.leftOperand=current} operator=('*' | '/' | 'div' | 'mod')) rightOperand=ExponentExpression)*
	;

ExponentExpression returns Expression
	: SpawnOperation (=> ({BinaryOperation.leftOperand=current} operator='^') rightOperand=SpawnOperation)*
	;

SpawnOperation returns Expression
	: UnaryOperation (=> ({SpawnOperation.operand=current} 'as' spawnTargetType=LocalName))?
	;

UnaryOperation returns Expression
	: {UnaryOperation} operator=('not' | '-') operand=FunctionedExpression
    | FunctionedExpression
    ;

FunctionedExpression returns Expression
	: NavigationExpression ({FunctionedExpression.operand=current} functionCall=FunctionCall)?
	;

NavigationExpression returns Expression
	: PrimaryExpression features+=Feature*
    | NavigationBase
    | EnumLiteralReference
    | PrimitiveDeclaration
    ;

PrimaryExpression returns Expression
	: ParenthesizedExpression
	| CreateExpression
	| Literal
	;


NavigationBase returns Expression
	: {NavigationBase} (isSelf ?= 'self' | navigationBaseType = [NavigationBaseReference | LocalName]) (features+=Feature*)
	| QueryCall (features+=Feature*)
	;

NavigationBaseReference
	: EntityDeclaration
	| QueryDeclaration
	| LambdaVariable
	| QueryDeclarationParameter
	;
	
	
QueryCall returns NavigationBase
	: queryDeclarationType = [ QueryDeclaration | LocalName ] '(' (parameters+=QueryParameter (',' parameters+=QueryParameter)*)? ')'
	;

EnumLiteralReference returns Expression
    : {EnumLiteralReference} enumDeclaration = [EnumDeclaration | LocalName] '#' enumLiteral = [EnumLiteral | EnumLiteralName ]    	
    ;

FunctionCall
	: {FunctionCall} '!' function=Function features+=Feature* call=FunctionCall?
	;

Feature
    : {Feature} {Feature.base = current} '.' navigationTargetType = [NavigationTarget | LocalName]('(' (parameters+=QueryParameter (',' parameters+=QueryParameter)*)? ')')?
    ;

NavigationTarget
    : EntityMemberDeclaration
    | EntityDeclaration
    ;


QueryParameter
	:  queryParameterType=[QueryDeclarationParameter | QueryParameterName] '=' (literal = Literal | parameter = [QueryDeclarationParameter | QueryParameterName])     // expression=MultilineExpression
	;

ParenthesizedExpression returns Expression
	: {ParenthesizedExpression} '(' =>expression = MultilineExpression ')'
	;


CreateExpression returns Expression
	: {CreateExpression} 'new' createType=[ClassDeclaration | LocalName]
	  (   '(' (assignments+=CreateParameter (',' assignments+=CreateParameter)*)? ')'
	  	| '[' (creates += MultilineExpression (',' creates += MultilineExpression)*)? ']'
	  )
	;

CreateParameter:
    name=JslID '=' right=MultilineExpression;


Function
	: SelectableFunction
    ;



 
NamedFunction returns Function : {NamedFunction} name = JslID
;
// String functions
GetVariableFunction returns LiteralFunction : {LiteralFunction} name = 'getVariable' '(' parameters += FunctionParameter ')' ;
IsDefinedFunction returns LiteralFunction : {LiteralFunction} name = 'isDefined' '(' ')';
IsUnDefinedFunction returns LiteralFunction : {LiteralFunction} name = 'isUnDefined' '(' ')';
LengthFunction returns LiteralFunction : {LiteralFunction} name = 'length' '(' ')';
FirstFunction returns LiteralFunction : {LiteralFunction} name = 'first' '(' 'count' '=' parameters += FunctionParameter ')';
LastFunction returns LiteralFunction : {LiteralFunction} name = 'last' '(' 'count' '=' parameters += FunctionParameter ')';
PositionFunction returns LiteralFunction : {LiteralFunction} name = 'position' '(' 'offset' '='parameters += FunctionParameter ')';
SubstringFunction returns LiteralFunction : {LiteralFunction} name = 'substring' '(' 'offset' '=' parameters += FunctionParameter ',' 'count' '=' parameters += FunctionParameter ')';
LowerFunction returns LiteralFunction : {LiteralFunction} name = 'lower' '(' ')';
UpperFunction returns LiteralFunction : {LiteralFunction} name = 'upper' '(' ')';
CapitalizeFunction returns LiteralFunction : {LiteralFunction} name = 'capitalize' '(' ')';
MatchesFunction returns LiteralFunction : {LiteralFunction} name = 'matches' '(' 'pattern' '=' parameters += FunctionParameter ')';
LikeFunction returns LiteralFunction : {LiteralFunction} name = 'like' '(' 'pattern' '=' parameters += FunctionParameter ')';
IlikeFunction returns LiteralFunction : {LiteralFunction} name = 'ilike' '(' 'pattern' '=' parameters += FunctionParameter ')';
ReplaceFunction returns LiteralFunction : {LiteralFunction} name = 'replace' '(' 'pattern' '=' parameters += FunctionParameter ',' 'replacement' '=' parameters += FunctionParameter ')';
TrimFunction returns LiteralFunction : {LiteralFunction} name = 'trim' '(' ')';
LtrimFunction returns LiteralFunction : {LiteralFunction} name = 'ltrim' '(' ')';
RtrimFunction returns LiteralFunction : {LiteralFunction} name = 'rtrim' '(' ')';

// Numeric functions
RoundFunction returns LiteralFunction : {LiteralFunction} name = 'round' '(' ')';
FloorFunction returns LiteralFunction : {LiteralFunction} name = 'floor' '(' ')';
CeilFunction returns LiteralFunction : {LiteralFunction} name = 'ceil' '(' ')';
AbsFunction returns LiteralFunction : {LiteralFunction} name = 'abs' '(' ')';
AsStringFunction returns LiteralFunction : {LiteralFunction} name = 'asString' '(' ')';

// Boolean functions
// AsStringFunction returns Named : {AsBooleanAsStringFunction} name = 'asString' '(' ')';

// Date functions
YearFunction returns LiteralFunction : {LiteralFunction} name = 'year' '(' ')';
MonthFunction returns LiteralFunction : {LiteralFunction} name = 'month' '(' ')';
DayFunction returns LiteralFunction : {LiteralFunction} name = 'day' '(' ')';
DateOfFunction returns LiteralFunction : {LiteralFunction} name = 'of' '('
	  ('year' '=' parameters += FunctionParameter ',' 'month' '=' parameters += FunctionParameter ',' 'day' '=' parameters += FunctionParameter) 
	')'
	;
// AsStringFunction returns Named : {AsStringFunction} name = 'asString' '(' ')';

// Time functions
HourFunction returns LiteralFunction : {LiteralFunction} name = 'hour' '(' ')';
MinuteFunction returns LiteralFunction : {LiteralFunction} name = 'minute' '(' ')';
SecondFunction returns LiteralFunction : {LiteralFunction} name = 'second' '(' ')';
TimeOfFunction returns LiteralFunction : {LiteralFunction} name = 'of' '('
	('hour' '=' parameters += FunctionParameter ',' 'minute' '=' parameters += FunctionParameter ',' 'second' '=' parameters += FunctionParameter)
	')'
	;

// OfFunction returns Named : {OfFunction} name = 'of' '(' args = TwoArg | ThreeArg  ')';
// AsStringFunction returns Named : {AsStringFunction} name = 'asString' '(' ')';

// Timestamp functions
DateFunction returns LiteralFunction : {LiteralFunction} name = 'date' '(' ')';
TimeFunction returns LiteralFunction : {LiteralFunction} name = 'time' '(' ')';
AsMillisecondsFunction returns LiteralFunction : {LiteralFunction} name = 'asMilliseconds' '(' ')';
FromMillisecondsFunction returns LiteralFunction : {LiteralFunction} name = 'fromMilliseconds' '(' 'millisecond' '=' parameters += FunctionParameter ')';
PlusMillisecondsFunction returns LiteralFunction : {LiteralFunction} name = 'plusMilliseconds' '(' 'millisecond' '=' parameters += FunctionParameter ')';
PlusSecondsFunction returns LiteralFunction : {LiteralFunction} name = 'plusSeconds' '(' 'sec' '=' parameters += FunctionParameter ')';
PlusMinutesFunction returns LiteralFunction : {LiteralFunction} name = 'plusMinutes' '(' 'min' '=' parameters += FunctionParameter ')';
PlusHoursFunction returns LiteralFunction : {LiteralFunction} name = 'plusHours' '(' 'hour' '=' parameters += FunctionParameter ')';
PlusDaysFunction returns LiteralFunction : {LiteralFunction} name = 'plusDays' '(' 'day' '=' parameters += FunctionParameter ')';
PlusMonthsFunction returns LiteralFunction : {LiteralFunction} name = 'plusMonths' '(' 'month' '=' parameters += FunctionParameter ')';
PlusYearsFunction returns LiteralFunction : {LiteralFunction} name = 'plusYears' '(' 'year' '=' parameters += FunctionParameter ')';
// AsStringFunction returns Named : {AsBooleanAsStringFunction} name = 'asString' '(' ')';
TimestampOfFunction returns LiteralFunction : {LiteralFunction} name = 'of' '('
	('date' '=' parameters += FunctionParameter ',' 'time' '=' parameters += FunctionParameter)
	')'
	;

// Enumeration functions

// AsStringFunction returns Named : {AsBooleanAsStringFunction} name = 'asString' '(' ')';

// Instance functions
TypeOfFunction returns InstanceFunction : {InstanceFunction} name = 'typeOf' '(' entityDeclaration = [EntityDeclaration | LocalName] ')';
KindOfFunction returns InstanceFunction : {InstanceFunction} name = 'kindOf' '(' entityDeclaration = [EntityDeclaration | LocalName] ')';
ContainerFunction returns InstanceFunction : {InstanceFunction} name = 'container' '(' entityDeclaration = [EntityDeclaration | LocalName] ')';
AsTypeFunction returns InstanceFunction : {InstanceFunction} name = 'asType' '(' entityDeclaration = [EntityDeclaration | LocalName] ')';

MemberOfFunction returns LiteralFunction : {LiteralFunction} name = 'memberOf' '(' parameters += FunctionParameter ')';

// Collection function
HeadFunction returns SelectorFunction : {SelectorFunction} name = 'head' '(' selectorArgument = SelectorFunctionParameters ')';
TailFunction returns SelectorFunction : {SelectorFunction} name = 'tail' '(' selectorArgument = SelectorFunctionParameters ')';
AnyFunction returns LambdaFunction : {LambdaFunction} name = 'any' '(' ')';
CountFunction returns LiteralFunction : {LiteralFunction} name = 'count' '(' ')';
AsCollectionFunction returns InstanceFunction : {InstanceFunction} name = 'asCollection' '(' entityDeclaration = [EntityDeclaration | LocalName] ')';
ContainsFunction returns LiteralFunction : {LiteralFunction} name = 'contains' '(' parameters += FunctionParameter ')';
FilterFunction returns LambdaFunction : {LambdaFunction} name = 'filter' '(' lambdaArgument = LambdaFunctionParameters ')';
AnyTrueFunction returns LambdaFunction : {LambdaFunction} name = 'anyTrue' '(' lambdaArgument = LambdaFunctionParameters ')';
AllTrueFunction returns LambdaFunction : {LambdaFunction} name = 'allTrue' '(' lambdaArgument = LambdaFunctionParameters ')';
MinFunction returns LambdaFunction : {LambdaFunction} name = 'min' '(' lambdaArgument = LambdaFunctionParameters ')';
MaxFunction returns LambdaFunction : {LambdaFunction} name = 'max' '(' lambdaArgument = LambdaFunctionParameters ')';
AvgFunction returns LambdaFunction : {LambdaFunction} name = 'avg' '(' lambdaArgument = LambdaFunctionParameters ')';
SumFunction returns LambdaFunction : {LambdaFunction} name = 'sum' '(' lambdaArgument = LambdaFunctionParameters ')';

LambdaFunction returns NamedFunction : {LambdaFunction} lambdaArgument = LambdaFunctionParameters;
LiteralFunction returns NamedFunction : {LiteralFunction} parameters += FunctionParameter;
InstanceFunction returns NamedFunction : {InstanceFunction} entityDeclaration = [EntityDeclaration | LocalName];
SelectorFunction returns NamedFunction : {SelectorFunction} selectorArgument = SelectorFunctionParameters;
 
SelectableFunction 
    : GetVariableFunction | IsDefinedFunction | IsUnDefinedFunction | LengthFunction | FirstFunction | LastFunction | PositionFunction | SubstringFunction 
    | LowerFunction | UpperFunction | CapitalizeFunction | MatchesFunction | LikeFunction | IlikeFunction | ReplaceFunction | TrimFunction | LtrimFunction | RtrimFunction | RoundFunction
    | FloorFunction | CeilFunction | AbsFunction | AsStringFunction | YearFunction | MonthFunction | DayFunction | DateOfFunction | HourFunction | MinuteFunction
    | SecondFunction | TimeOfFunction | DateFunction | TimeFunction | AsMillisecondsFunction | FromMillisecondsFunction | PlusMillisecondsFunction | PlusSecondsFunction
    | PlusMinutesFunction | PlusHoursFunction | PlusDaysFunction | PlusMonthsFunction | PlusYearsFunction | TimestampOfFunction | TypeOfFunction | KindOfFunction | ContainerFunction
    | AsTypeFunction | MemberOfFunction | HeadFunction | TailFunction | AnyFunction | CountFunction | AsCollectionFunction | ContainsFunction | FilterFunction
    | AnyTrueFunction | AllTrueFunction | MinFunction | MaxFunction | AvgFunction | SumFunction
    ;


LambdaFunctionParameters
    : lambdaArgument=LambdaVariable '|' expression = Expression
	;
    
LambdaVariable
    : {LambdaVariable} Named    	
    ;

SelectorFunctionParameters
    : selectorArgument=SelectorVariable '|' selectors += SelectorDeclaration (',' selectors += SelectorDeclaration)*
	;

SelectorDeclaration
    : {SelectorDeclaration} selector = [SelectorVariable | LocalName] '.' member = [EntityMemberDeclaration | LocalName] ('DESC' | isTrue?='ASC')?
    ;

SelectorVariable
    : {SelectorVariable} Named
    ;

FunctionParameter
	: {FunctionParameter} expression=MultilineExpression
	;

Literal returns Expression
	: BooleanLiteral
	| NumberLiteral
	| StringLiteral
	| TemporalLiteral
	;

BooleanLiteral returns Expression
	: {BooleanLiteral} ('false' | isTrue?='true')
	;

NumberLiteral returns Expression
	: {IntegerLiteral} value=INTEGER
	| {DecimalLiteral} value=DECIMAL
	;

StringLiteral returns Expression
	: {EscapedStringLiteral} value=STRING
	| {RawStringLiteral} value=RAW_STRING
	;

TemporalLiteral returns Expression
	: {DateLiteral} value=DATE
	| {TimeStampLiteral} value=TIMESTAMP
	| {TimeLiteral} value=TIME
	;


EnumLiteralName
	: JslID
    ;

QueryParameterName
	: JslID
    ;

LocalName
	: (ID '::')? JslID
    ;

ModelName
	: ID('::' JslID)*
    ;

/****************************
 *	Terminals
 ****************************/

BLOCK_START
	: NL* '{'
	;

BLOCK_END
	: NL* '}'
	;


terminal fragment DIGIT
	: '0'..'9'
	;

terminal fragment ALPHABET
    : 'a'..'z' | 'A'..'Z'    	
    ;

terminal fragment NEWLINE
    : '\n' | '\r'   	
    ;

terminal TIMESTAMP
	: '`' DIGIT+ '-' DIGIT DIGIT '-' DIGIT DIGIT 'T' DIGIT DIGIT ':' DIGIT DIGIT (':' DIGIT DIGIT ('.' DIGIT+ )? )? ('Z' | ('+' | '-') DIGIT DIGIT ':' DIGIT DIGIT )'`'
	;

terminal TIME
	: '`' DIGIT DIGIT ':' DIGIT DIGIT (':' DIGIT DIGIT ('.' DIGIT+ )? )? '`'
	;

terminal DATE
	: '`' DIGIT+ '-' DIGIT DIGIT '-' DIGIT DIGIT '`'
	;


terminal DECIMAL returns ecore::EBigDecimal
	: '-'? DIGIT+ '.' DIGIT+
	;

terminal INTEGER returns ecore::EBigInteger
	: '-'? DIGIT+
	;

terminal ID
	: '\\'? ALPHABET (ALPHABET | DIGIT)*
	;

terminal STRING
	: '"' ('\\' ('t'|'n'|'f'|'r'|'"'|'\\') | !('\\' | '"' | NEWLINE))* '"'
	;

terminal RAW_STRING
	: 'r"' (!('"' | NEWLINE))* '"'
	;


terminal MIME_TYPE
    : 'm"' (ALPHABET)+ '/' ('*' | (ALPHABET)+ ('.' (ALPHABET)+)* ) '"'
	;

terminal CONT_NL
	: '\\' (' ' | '\t')* '\r'? '\n'
	;
 
terminal ML_COMMENT
	: '/*'->'*/'
	;

terminal SL_COMMENT
	: '//' !(NEWLINE)*
	;

terminal WS
	: (' ' | '\t')+
	;

terminal NL
	: NEWLINE | ';'
	;

terminal ANY_OTHER
	: .
	;
