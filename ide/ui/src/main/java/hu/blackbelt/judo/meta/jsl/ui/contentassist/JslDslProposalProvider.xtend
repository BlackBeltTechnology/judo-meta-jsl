/*
 * generated by Xtext 2.18.0
 */
package hu.blackbelt.judo.meta.jsl.ui.contentassist

import com.google.inject.Inject
import org.eclipse.xtext.CrossReference
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor
import org.eclipse.xtext.Assignment
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext
import hu.blackbelt.judo.meta.jsl.jsldsl.EntityRelationDeclaration
import hu.blackbelt.judo.meta.jsl.jsldsl.EntityRelationOpposite
import hu.blackbelt.judo.meta.jsl.util.JslDslModelExtension
import hu.blackbelt.judo.meta.jsl.jsldsl.EntityDeclaration
import org.eclipse.xtext.Keyword
import java.util.Set
import com.google.common.collect.ImmutableSet
import hu.blackbelt.judo.meta.jsl.jsldsl.ModelDeclaration
import hu.blackbelt.judo.meta.jsl.jsldsl.Expression
import org.eclipse.xtext.RuleCall
import org.eclipse.xtext.AbstractRule
import org.eclipse.jface.text.contentassist.ICompletionProposal

/**
 * See https://www.eclipse.org/Xtext/documentation/304_ide_concepts.html#content-assist
 * on how to customize the content assistant.
 */
class JslDslProposalProvider extends AbstractJslDslProposalProvider {
    // TODO: https://stackoverflow.com/questions/47005235/customizing-content-proposal-in-xtext-for-web-editors
    @Inject extension JslDslModelExtension

    public static Set<String> FILTERED_KEYWORDS = ImmutableSet.of("lambda", "function");

    public static Set<String> FILTERED_TERMINALS = ImmutableSet.of("{", "}", ";", "(", ")", "+", "-", "*", "/", "@",
                                                                  "!=", "<", ">", ">=", "==", "?", "^",
                                                                  "and", "div", "implies", "mod", "or", "xor");

    override completeKeyword(Keyword keyword, ContentAssistContext contentAssistContext, ICompletionProposalAcceptor acceptor) {
        if (FILTERED_KEYWORDS.contains(keyword.getValue()) && contentAssistContext.currentModel instanceof ModelDeclaration) {
            // don't propose keyword
            return;
        }

        if (FILTERED_TERMINALS.contains(keyword.getValue())) {
            // don't propose keyword
            return;
        }

        if (keyword.getValue().equals("self") &&
            contentAssistContext.currentNode.semanticElement.parentContainer(Expression) !== null &&
            contentAssistContext.currentNode.semanticElement.parentContainer(EntityDeclaration) === null
        ) {
            // don't propose keyword
            return;
        }

        super.completeKeyword(keyword, contentAssistContext, acceptor);
    }

	override completeRuleCall(RuleCall ruleCall, ContentAssistContext contentAssistContext,
			ICompletionProposalAcceptor acceptor) {

		var AbstractRule calledRule = ruleCall.getRule();
		
		if (calledRule.alternatives instanceof Keyword) {
			var Keyword keyword = calledRule.alternatives as Keyword;
			completeKeyword(keyword, contentAssistContext, acceptor)
		}
				
		super.completeRuleCall(ruleCall, contentAssistContext, acceptor)
	}


    override completeEntityRelationOppositeReferenced_OppositeType(EObject model, Assignment assignment,
        ContentAssistContext context, ICompletionProposalAcceptor acceptor
    ) {
        // System.out.println("model: " + model + " assignment: " + assignment + " context: " + context)
        lookupCrossReference((assignment.getTerminal() as CrossReference), context, acceptor,
            [ ((model as EntityRelationOpposite).eContainer as EntityRelationDeclaration)
                .isSelectableForRelation(EObjectOrProxy as EntityRelationDeclaration)
            ]
        );
    }

    override completeEntityDeclaration_Extends(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
        // System.out.println(" - model: " + model + " assignment: " + assignment + " context: " + context)
        lookupCrossReference((assignment.getTerminal() as CrossReference), context, acceptor,
            [
                val entity = model as EntityDeclaration;
                val proposedEntity = EObjectOrProxy as EntityDeclaration
                // System.out.println(" --- Obj: " + EObjectOrProxy + " - " + superEntities.join(", "))

                proposedEntity !== entity && !proposedEntity.superEntityTypes.contains(entity)
            ]
        );
    }

/*
    override completeCreateExpression_Type(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
        lookupCrossReference((assignment.getTerminal() as CrossReference), context, acceptor, [
            false
        ]);
    }
*/
/*     override completeNavigationBase_EnumValue(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
        lookupCrossReference((assignment.getTerminal() as CrossReference), context, acceptor, [
            true
        ]);
    }
*/
}
